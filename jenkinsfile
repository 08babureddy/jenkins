pipeline {
    agent any
    environment {
        WORKSPACE = "${env.WORKSPACE}"
    }
    stages {
        stage('Setup') {
            steps {
                script {
                    sh 'python3 -m venv venv'
                    sh 'source venv/bin/activate && pip install -r requirements.txt'
                }
            }
        }
        stage('Test') {
            steps {
                script {
                    // Running multiple commands in a shell step
                    sh '''
                    source venv/bin/activate && python -m behave --tags ${tagname}
                    '''
                }
            }
        }
    }
    post {
        always {
            script {
                // Defining variables for the email content inside the script block
                def pipeline_name = env.JOB_NAME
                def build_number = currentBuild.number
                def buildStatus = currentBuild.result ?: 'UNKNOWN' // Handling null or empty status
                def latest_folder_path = sh(script: "ls -dt ${WORKSPACE}/results/html/* | head -n 1", returnStdout: true).trim()

                def latest_folder_name = sh(script: "basename \"${latest_folder_path}\"", returnStdout: true).trim()

                def html_file_path = sh(script: "ls -t ${latest_folder_path}/*.html | head -n 1", returnStdout: true).trim()

                def latest_html_file_name = sh(script: "basename \"${html_file_path}\"", returnStdout: true).trim()

                def json_file_path = sh(script: "ls -t ${WORKSPACE}/results/json/${latest_folder_name}/*.json | head -n 1",returnStdout: true).trim()

                // Check if the JSON file exists
                def jsonFile = new File(json_file_path)
                if (!jsonFile.exists()) {
                    error "JSON file not found: ${json_file_path}"
                }

                def jsonContent = readFile(file: json_file_path)
                def testResults = new groovy.json.JsonSlurper().parseText(jsonContent)

                // Start creating the table with only Test Case and Status
                def htmlTable = "<table border='1' style='border-collapse: collapse;'><tr><th>Test Case</th><th>Status</th></tr>"

                testResults.each { testCaseName, details ->
                    // Adding the result of the test case (Pass or Fail)
                    def result = details.any { it.value == false } ? 'Fail' : 'Pass'
                    htmlTable += "<tr><td>${testCaseName}</td><td>${result}</td></tr>"
                }

                htmlTable += "</table>"

                // Sending the email with the build status
                emailext(
                    subject: "${pipeline_name} - Build #${build_number} - ${buildStatus}",
                    body: """
                        <h3>Test Results for Build ${build_number}</h3>
                        <p>Status: ${buildStatus}</p>
                        <p>Click <a href="file://${latest_folder_path}/${latest_html_file_name}">here</a> to view the HTML report.</p>
                        <h4>Test Results</h4>
                        ${htmlTable}
                        <h4> ***Checking the format and attachment*** </h4>
                        <p><i> The pipeline was run locally by creating it from a GitHub repository. </i></p>
                    """,
                    to: 'chinnareddy.b@datapoem.com',
                    mimeType: 'text/html',
                    attachmentsPattern: "results/html/${latest_folder_name}/*.html"
                )
            }
        }
    }
}
